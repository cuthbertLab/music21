.. _usersGuide_09_chordify:

.. WARNING: DO NOT EDIT THIS FILE:
   AUTOMATICALLY GENERATED.
   PLEASE EDIT THE .py FILE DIRECTLY.


.. code:: ipython3


User's Guide, Chapter 9: Chordify
=================================

**Chordify** is a madeup word that we created in ``music21`` for the
process of making chords out of non-chords. Chordify powerful tool for
reducing a complex score with multiple parts to a succession of chords
in one part that represent everything that is happening in the score.
Take this short chorale by Bach:

.. code:: ipython3

    from music21 import *
    
    b = corpus.parse('bwv66.6')
    b.show()



.. image:: usersGuide_09_chordify_3_0.png
   :width: 748px
   :height: 1015px


Let's take it and chordify it using the
:meth:`~music21.stream.Stream.chordify` method.

.. code:: ipython3

    bChords = b.chordify()
    bChords.show()



.. image:: usersGuide_09_chordify_5_0.png
   :width: 751px
   :height: 454px


TA-DA! Every note in the score is now represented in a single chord and
every moment where some element moves is also represented. Sometimes
this process of chordifying is called "salami slicing," that is, cutting
the score so thinly that every moment where something happens is fully
represented.

Now we can see if there are any (fully-notated) dominant seventh chords
in the piece. The new chordified part still has measures, so we'll
recurse into the chordified part first to get to the chords. It might
also have time signatures, etc., so we will filter them out so we only
have chords.

.. code:: ipython3

    for thisChord in bChords.recurse().getElementsByClass('Chord'):
        if thisChord.isDominantSeventh():
            print(thisChord.measureNumber, thisChord.beatStr, thisChord)


.. parsed-literal::
   :class: ipython-result

    2 2 1/2 <music21.chord.Chord B4 G#4 D4 E3>
    3 2 1/2 <music21.chord.Chord G#4 E#4 B3 C#3>
    4 3 1/2 <music21.chord.Chord F#4 D#4 A3 B2>
    8 2 <music21.chord.Chord F#4 E4 C#4 A#2>


Sure enough we can check the score above and see that there are four of
them: three of them on the offbeat (m.2 beat 2.5, m. 3 beat 2.5, and m.
4 beat 3.5) which are made from passing motion, and one of them in m. 8
beat 2 also in a metrically weak position.

We can see the chordified version by callling ".show()" on ``bChords``
itself, but it's probably better to see it in the context of the whole
score. Let's put it in the score at the beginning (all ``Part`` objects
should go at the beginning) and then show just measures 0 (pickup) to 4:

.. code:: ipython3

    b.insert(0, bChords)
    b.measures(0, 4).show()



.. image:: usersGuide_09_chordify_10_0.png
   :width: 748px
   :height: 903px


That's a bit messy to read, so let's put all these chords in
``closedPosition`` (see
:ref:`User's Guide, Chapter 7: Chords <usersGuide_07_chords>` for more
information).

.. code:: ipython3

    for c in bChords.recurse().getElementsByClass('Chord'):
        c.closedPosition(forceOctave=4, inPlace=True)
    
    b.measures(0,2).show()



.. image:: usersGuide_09_chordify_12_0.png
   :width: 748px
   :height: 448px


Note that when we move a chord to closed position, unfortunately it
loses its ``tie`` information, since the pitch that starts a tie can't
tell whether or not the next pitch will end up in a different octave
(for instance, the Cs in the first two notes of the second full
measure). Maybe it's something we can do someday...

We can use the function ``roman.romanNumeralFromChord`` to label each of
the chordified Chords:

.. code:: ipython3

    for c in bChords.recurse().getElementsByClass('Chord'):
        rn = roman.romanNumeralFromChord(c, key.Key('A'))
        c.addLyric(str(rn.figure))
        
    b.measures(0, 2).show()



.. image:: usersGuide_09_chordify_14_0.png
   :width: 748px
   :height: 464px


We can also see everything directly if we look at the ``.show('text')``
output:

.. code:: ipython3

    bChords.measures(0,2).show('text')


.. parsed-literal::
   :class: ipython-result

    {0.0} <music21.stream.Measure 0 offset=0.0>
        {0.0} <music21.clef.TrebleClef>
        {0.0} <music21.key.Key of f# minor>
        {0.0} <music21.meter.TimeSignature 4/4>
        {0.0} <music21.chord.Chord A4 C#5 E5>
        {0.5} <music21.chord.Chord G#4 B4 E5>
    {1.0} <music21.stream.Measure 1 offset=1.0>
        {0.0} <music21.chord.Chord F#4 A4 C#5>
        {1.0} <music21.chord.Chord G#4 B4 E5>
        {2.0} <music21.chord.Chord A4 C#5 E5>
        {3.0} <music21.chord.Chord G#4 B4 E5>
    {5.0} <music21.stream.Measure 2 offset=5.0>
        {0.0} <music21.chord.Chord A4 C#5 E5>
        {0.5} <music21.chord.Chord C#4 E4 A4>
        {1.0} <music21.chord.Chord E4 G#4 B4>
        {1.5} <music21.chord.Chord E4 G#4 B4 D5>
        {2.0} <music21.chord.Chord A4 C#5 E5>
        {3.0} <music21.chord.Chord E#4 G#4 C#5>


We can also just extract the lyrics, where we stored the RomanNumeral
information:

.. code:: ipython3

    for c in bChords.measures(0,2).flat:
        if 'Chord' not in c.classes:
            continue
        print(c.lyric, end=' ')


.. parsed-literal::
   :class: ipython-result

    I V6 vi V6 I V6 I I6 V V7 I III6 

More complex scores can also be chordified. If there are lots of
tuplets, you might get odd results. Such as with Opus 19, no. 6, by
Arnold Schoenberg.

.. code:: ipython3

    schoenberg = corpus.parse('schoenberg/opus19', 6)
    schoenberg.show()



.. image:: usersGuide_09_chordify_20_0.png
   :width: 752px
   :height: 651px


.. code:: ipython3

    schoenberg.chordify().show()



.. image:: usersGuide_09_chordify_21_0.png
   :width: 751px
   :height: 473px


There are more specialized commands for ``.chordify``, so if you want to
learn more, look at the :meth:`~music21.stream.Stream.chordify`
documentation. We will get to the option, ``addPartNameAsGroup`` later,
which will let you know exactly where each pitch in the chordified Chord
comes from. But for now, let's jump to our first example,
:ref:`Chapter 10: Example 1 <usersGuide_10_examples1>`