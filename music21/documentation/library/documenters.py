# -*- coding: utf-8 -*-
#-------------------------------------------------------------------------------
# Name:         documentation/library/documenters.py
# Purpose:      music21 documentation helper classes for proper formatting
#
# Authors:      Josiah Wolf Oberholtzer
#
# Copyright:    Copyright Â© 2013-14 Michael Scott Cuthbert and the music21 Project
# License:      LGPL or BSD, see license.txt
#------------------------------------------------------------------------------

import inspect
import re
import types
import unittest

from music21.ext import six
if six.PY3:
    unicode = str # @ReservedAssignment

class Documenter(object):
    '''
    Abstract base class for documenting classes.
    '''
    def run(self):
        raise NotImplemented

    def __repr__(self):
        raise NotImplemented

    ### PRIVATE PROPERTIES ###

    @property
    def _packagesystemPath(self):
        return '.'.join((
            self.__class__.__module__,
            self.__class__.__name__,
            ))

    ### PUBLIC PROPERTIES ###

    @property
    def rstEditingWarningFormat(self):
        result = []
        result.append('.. WARNING: DO NOT EDIT THIS FILE:')
        result.append('   AUTOMATICALLY GENERATED.')
        result.append('   PLEASE EDIT THE .py FILE DIRECTLY.')
        result.append('')
        return result

    ### PUBLIC METHODS ###

    @staticmethod
    def makeHeading(text, heading_level):
        assert isinstance(text, (str, unicode)) and len(text)
        heading_characters = ['=', '-', '^', '"']
        result = [text]
        result.append(heading_characters[heading_level - 1] * len(text))
        result.append('')
        return result

    @staticmethod
    def makeRubric(text):
        return ['.. rubric:: {}'.format(text), '']


class ObjectDocumenter(Documenter):
    '''
    Base class for object documenting classes.
    '''

    ### INITIALIZER ###

    def __init__(self, referent):
        self._referent = referent

    ### PUBLIC PROPERTIES ###

    @property
    def referent(self):
        return self._referent

    def referentPackagesystemPath(self):
        raise NotImplemented

    def rstAutodocDirectiveFormat(self):
        raise NotImplemented

    @property
    def rstCrossReferenceString(self):
        return ':{0}:`~{1}`'.format(
            self.sphinxCrossReferenceRole,
            self.referentPackagesystemPath,
            )

    def sphinxCrossReferenceRole(self):
        raise NotImplemented


class FunctionDocumenter(ObjectDocumenter):
    '''
    A documenter for one function:

    >>> from music21 import common, documentation
    >>> function = common.opFrac
    >>> documenter = documentation.FunctionDocumenter(function)
    >>> documenter
    <music21.documentation.library.documenters.FunctionDocumenter: music21.common.opFrac>

    >>> documenter.rstCrossReferenceString
    ':func:`~music21.common.opFrac`'

    >>> for line in documenter.rstAutodocDirectiveFormat:
    ...     line
    ...
    '.. autofunction:: music21.common.opFrac'
    ''

    Call the documenter to generate its ReStructuredText format:

    >>> restructuredText = documenter.run()

    '''

    ### INITIALIZER ###

    def __init__(self, referent):
        assert isinstance(referent, types.FunctionType)
        ObjectDocumenter.__init__(self, referent)

    ### SPECIAL METHODS ###

    def run(self):
        result = []
        result.extend(self.rstAutodocDirectiveFormat)
        return result

    def __repr__(self):
        return '<{0}: {1}>'.format(
            self._packagesystemPath,
            self.referentPackagesystemPath,
            )

    ### PUBLIC PROPERTIES ###

    @property
    def referentPackagesystemPath(self):
        path = '.'.join((
            self.referent.__module__,
            self.referent.__name__,
            ))
        return path.replace('.__init__', '')

    @property
    def rstAutodocDirectiveFormat(self):
        result = []
        referentPackagesystemPath = self.referentPackagesystemPath.replace(
            '.__init__', '')
        result.append('.. autofunction:: {0}'.format(
            referentPackagesystemPath,
            ))
        result.append('')
        return result

    @property
    def sphinxCrossReferenceRole(self):
        return 'func'


class MemberDocumenter(ObjectDocumenter):
    '''
    Abstract base class for documenting class members.
    '''

    ### INITIALIZER ###

    def __init__(self, referent, memberName, definingClass):
        assert isinstance(definingClass, six.class_types)
        ObjectDocumenter.__init__(self, referent)
        self._memberName = memberName
        self._definingClass = definingClass

    ### SPECIAL METHODS ###

    def run(self):
        result = []
        result.extend(self.rstAutodocDirectiveFormat)
        return result

    def __repr__(self):
        referentPath = '.'.join((
            self.definingClass.__module__,
            self.definingClass.__name__,
            self.memberName,
            ))
        return '<{0}: {1}>'.format(
            self._packagesystemPath,
            referentPath,
            )

    ### PUBLIC PROPERTIES ###

    @property
    def definingClass(self):
        return self._definingClass

    @property
    def memberName(self):
        return self._memberName

    @property
    def referentPackagesystemPath(self):
        path = '.'.join((
            self.definingClass.__module__,
            self.definingClass.__name__,
            self.memberName,
            ))
        return path.replace('.__init__', '')


class MethodDocumenter(MemberDocumenter):
    '''
    A documenter for class methods:

    >>> from music21 import documentation, key
    >>> method = key.KeySignature.transpose
    >>> documenter = documentation.MethodDocumenter(
    ...     method, 'transpose', key.KeySignature)
    >>> documenter
    <music21.documentation.library.documenters.MethodDocumenter: music21.key.KeySignature.transpose>

    >>> documenter.rstCrossReferenceString
    ':meth:`~music21.key.KeySignature.transpose`'

    >>> for line in documenter.rstAutodocDirectiveFormat:
    ...     line
    ...
    '.. automethod:: music21.key.KeySignature.transpose'
    ''

    '''

    ### PUBLIC PROPERTIES ###

    @property
    def rstAutodocDirectiveFormat(self):
        result = []
        result.append('.. automethod:: {0}'.format(
            self.referentPackagesystemPath,
            ))
        result.append('')
        return result

    @property
    def sphinxCrossReferenceRole(self):
        return 'meth'


class AttributeDocumenter(MemberDocumenter):
    '''
    A documenter for class attributes, both read/write and read-only:

    >>> from music21 import documentation, key
    >>> attribute = key.KeySignature.mode
    >>> documenter = documentation.AttributeDocumenter(
    ...     attribute, 'mode', key.KeySignature)
    >>> documenter
    <music21.documentation.library.documenters.AttributeDocumenter: music21.key.KeySignature.mode>

    >>> documenter.rstCrossReferenceString
    ':attr:`~music21.key.KeySignature.mode`'

    >>> for line in documenter.rstAutodocDirectiveFormat:
    ...     line
    ...
    '.. autoattribute:: music21.key.KeySignature.mode'
    ''

    '''

    ### PUBLIC PROPERTIES ###

    @property
    def rstAutodocDirectiveFormat(self):
        result = []
        result.append('.. autoattribute:: {0}'.format(
            self.referentPackagesystemPath,
            ))
        result.append('')
        return result

    @property
    def sphinxCrossReferenceRole(self):
        return 'attr'


class ClassDocumenter(ObjectDocumenter):
    '''
    A documenter for one class:

    >>> from music21 import documentation
    >>> klass = documentation.ClassDocumenter
    >>> documenter = documentation.ClassDocumenter(klass)
    >>> documenter
    <music21.documentation.library.documenters.ClassDocumenter: music21.documentation.library.documenters.ClassDocumenter>

    >>> documenter.rstCrossReferenceString
    ':class:`~music21.documentation.library.documenters.ClassDocumenter`'


    >>> for line in documenter.rstAutodocDirectiveFormat:
    ...     line
    ...
    '.. autoclass:: music21.documentation.library.documenters.ClassDocumenter'
    ''

    Generate the ReST lines by calling `run` on the documenter:

    >>> restructedText = documenter.run()
    
    '''

    ### CLASS VARIABLES ###

    _identityMap = {}

    ### INITIALIZER ###

    def __init__(self, referent):
        assert isinstance(referent, six.class_types), repr(referent)
        ObjectDocumenter.__init__(self, referent)

        self._baseClasses = tuple(
            cls for cls in inspect.getmro(self.referent)[1:]
            if cls.__module__.startswith('music21'))
        self._baseClassDocumenters = tuple(
            type(self).fromIdentityMap(cls) for cls in self.baseClasses)

        self._docAttr = None
        attrs = inspect.classify_class_attrs(self.referent)
        docAttrAttr = [attr for attr in attrs if attr.name == '_DOC_ATTR']
        if docAttrAttr:
            docAttrAttr = docAttrAttr[0]
            if docAttrAttr.defining_class is self.referent:
                self._docAttr = self.referent._DOC_ATTR
        self._docOrder = getattr(self.referent, '_DOC_ORDER', [])

        inheritedDocAttr = {}
        for baseClass in self.baseClasses:
            baseClassDocAttr = getattr(baseClass, '_DOC_ATTR', None)
            if baseClassDocAttr is not None:
                baseClassDocumenter = type(self).fromIdentityMap(baseClass)
                inheritedDocAttr[baseClassDocumenter] = baseClassDocAttr
        self._inheritedDocAttrMapping = inheritedDocAttr

        methods = []
        inheritedMethods = {}

        # Read/Write
        readwriteProperties = []
        inheritedReadwriteProperties = {}

        # Read-only
        readonlyProperties = []
        inheritedReadonlyProperties = {}

        attrs = inspect.classify_class_attrs(self.referent)
        for attr in attrs:

            # Ignore definitions derived directly from object
            if attr.defining_class is object:
                continue
            # Ignore private members ('_') and special members ('__')
            elif attr.name.startswith('_'):
                continue

            definingClass = attr.defining_class
            if attr.kind in ('class method', 'method', 'static method'):
                documenterClass = MethodDocumenter
                localMembers = methods
                inheritedMembers = inheritedMethods
            elif attr.kind in ('property',) and attr.object.fset is not None:
                documenterClass = AttributeDocumenter
                localMembers = readwriteProperties
                inheritedMembers = inheritedReadwriteProperties
            elif attr.kind in ('property',) and attr.object.fset is None:
                documenterClass = AttributeDocumenter
                localMembers = readonlyProperties
                inheritedMembers = inheritedReadonlyProperties
            else:
                continue

            documenter = documenterClass(
                attr.object,
                attr.name,
                definingClass,
                )
            if definingClass is self.referent:
                localMembers.append(documenter)
            else:
                definingClassDocumenter = type(self).fromIdentityMap(
                    definingClass)
                if definingClassDocumenter not in inheritedMembers:
                    inheritedMembers[definingClassDocumenter] = []
                inheritedMembers[definingClassDocumenter].append(documenter)

        keyLambda = lambda x: x.memberName
        methods.sort(key=keyLambda)
        readonlyProperties.sort(key=keyLambda)
        readwriteProperties.sort(key=keyLambda)
        for documenters in inheritedMethods.values():
            documenters.sort(key=keyLambda)
        for documenters in inheritedReadonlyProperties.values():
            documenters.sort(key=keyLambda)
        for documenters in inheritedReadwriteProperties.values():
            documenters.sort(key=keyLambda)

        self._methods = methods
        self._readonlyProperties = readonlyProperties
        self._readwriteProperties = readwriteProperties
        self._inheritedDocAttrMapping = inheritedDocAttr
        self._inheritedMethodsMapping = inheritedMethods
        self._inheritedReadonlyPropertiesMapping = inheritedReadonlyProperties
        self._inheritedReadwritePropertiesMapping = \
            inheritedReadwriteProperties

        if self.referent not in self._identityMap:
            self._identityMap[self.referent] = self

    ### SPECIAL METHODS ###

    def run(self):
        result = []
        result.extend(self.makeHeading(self.referent.__name__, 2))
        result.extend(self.rstAutodocDirectiveFormat)
        result.extend(self.rstBasesFormat)
        result.extend(self.rstReadonlyPropertiesFormat)
        result.extend(self.rstReadwritePropertiesFormat)
        result.extend(self.rstMethodsFormat)
        result.extend(self.rstDocAttrFormat)
        return result

    def __hash__(self):
        return hash((type(self), self.referent))

    def __repr__(self):
        referentPath = '.'.join((
            self.referent.__module__,
            self.referent.__name__,
            ))
        return '<{0}: {1}>'.format(
            self._packagesystemPath,
            referentPath,
            )

    ### PRIVATE METHODS ###

    def _formatInheritedMembersMapping(self, mapping, banner):
        result = []
        if not mapping:
            return result
        for classDocumenter in self.baseClassDocumenters:
            if classDocumenter not in mapping:
                continue
            result.append(banner.format(
                classDocumenter.rstCrossReferenceString))
            result.append('')
            memberDocumenters = mapping[classDocumenter]
            result.append('.. hlist::')
            result.append('   :columns: 3')
            result.append('')
            for memberDocumenter in memberDocumenters:
                result.append('   - {0}'.format(
                    memberDocumenter.rstCrossReferenceString))
            result.append('')
        return result

    ### PUBLIC METHODS ###

    @classmethod
    def fromIdentityMap(cls, referent):
        if referent in cls._identityMap:
            return cls._identityMap[referent]
        return cls(referent)

    ### PUBLIC PROPERTIES ###

    @property
    def baseClasses(self):
        return self._baseClasses

    @property
    def baseClassDocumenters(self):
        return self._baseClassDocumenters

    @property
    def docAttr(self):
        '''
        The music21 _DOC_ATTR definition for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Stream
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for key in sorted(list(documenter.docAttr.keys())):
        ...     key
        ...
        'autoSort'
        'definesExplicitPageBreaks'
        'definesExplicitSystemBreaks'
        'isFlat'
        'isSorted'
        'recursionType'
        '''
        return self._docAttr

    @property
    def docOrder(self):
        '''
        The music21 _DOC_ORDER definition for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Stream
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for name in documenter.docOrder:
        ...     name
        ...
        'append'
        'insert'
        'insertAndShift'
        'notes'
        'pitches'
        'transpose'
        'augmentOrDiminish'
        'scaleOffsets'
        'scaleDurations'

        '''
        return self._docOrder

    @property
    def inheritedDocAttrMapping(self):
        '''
        A mapping of parent class documenters and doc-attr attribute dicts
        for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Measure
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> mapping = documenter.inheritedDocAttrMapping
        >>> sortBy = lambda x: x.referentPackagesystemPath
        >>> for classDocumenter in sorted(mapping, key=sortBy):
        ...     classDocumenter
        ...
        <music21.documentation.library.documenters.ClassDocumenter: music21.base.Music21Object>
        <music21.documentation.library.documenters.ClassDocumenter: music21.stream.Stream>

        '''
        return self._inheritedDocAttrMapping

    @property
    def inheritedReadonlyPropertiesMapping(self):
        '''
        A mapping of parent class documenters and inherited read-only
        properties for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Measure
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> mapping = documenter.inheritedReadonlyPropertiesMapping
        >>> sortBy = lambda x: x.referentPackagesystemPath
        >>> for classDocumenter in sorted(mapping, key=sortBy):
        ...     print('{0}:'.format(
        ...         classDocumenter.referentPackagesystemPath))
        ...     for attributeDocumenter in mapping[classDocumenter][:10]:
        ...         print('- {0}'.format(
        ...             attributeDocumenter.referentPackagesystemPath))
        ...
        music21.base.Music21Object:
        - music21.base.Music21Object.classes
        - music21.base.Music21Object.containerHierarchy
        - music21.base.Music21Object.derivation
        - music21.base.Music21Object.fullyQualifiedClasses
        - music21.base.Music21Object.isGrace
        - music21.base.Music21Object.measureNumber
        music21.stream.Stream:
        - music21.stream.Stream.beat
        - music21.stream.Stream.beatDuration
        - music21.stream.Stream.beatStr
        - music21.stream.Stream.beatStrength
        - music21.stream.Stream.flat
        - music21.stream.Stream.highestOffset
        - music21.stream.Stream.highestTime
        - music21.stream.Stream.isGapless
        - music21.stream.Stream.lowestOffset
        - music21.stream.Stream.notes

        '''

        return self._inheritedReadonlyPropertiesMapping

    @property
    def inheritedMethodsMapping(self):
        '''
        A mapping of parent class documenters and inherited attributes for a
        documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Measure
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> mapping = documenter.inheritedMethodsMapping
        >>> sortBy = lambda x: x.referentPackagesystemPath
        >>> for classDocumenter in sorted(mapping, key=sortBy):
        ...     print('{0}:'.format(
        ...         classDocumenter.referentPackagesystemPath))
        ...     for attributeDocumenter in mapping[classDocumenter][:10]:
        ...         print('- {0}'.format(
        ...             attributeDocumenter.referentPackagesystemPath))
        ...
        music21.base.Music21Object:
        - music21.base.Music21Object.contextSites      
        - music21.base.Music21Object.findAttributeInHierarchy
        - music21.base.Music21Object.getAllContextsByClass
        - music21.base.Music21Object.getContextAttr
        - music21.base.Music21Object.getContextByClass
        - music21.base.Music21Object.getOffsetBySite
        - music21.base.Music21Object.getSpannerSites
        - music21.base.Music21Object.hasSite
        - music21.base.Music21Object.isClassOrSubclass
        - music21.base.Music21Object.next
        music21.stream.Stream:
        - music21.stream.Stream.activateVariants
        - music21.stream.Stream.addGroupForElements
        - music21.stream.Stream.allPlayingWhileSounding
        - music21.stream.Stream.analyze
        - music21.stream.Stream.append
        - music21.stream.Stream.asTimespans
        - music21.stream.Stream.attachIntervalsBetweenStreams
        - music21.stream.Stream.attachMelodicIntervals
        - music21.stream.Stream.attributeCount
        - music21.stream.Stream.augmentOrDiminish

        '''
        return self._inheritedMethodsMapping

    @property
    def inheritedReadwritePropertiesMapping(self):
        '''
        A mapping of parent class documenters and inherited read/write
        properties for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Measure
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> mapping = documenter.inheritedReadwritePropertiesMapping
        >>> sortBy = lambda x: x.referentPackagesystemPath
        >>> for classDocumenter in sorted(mapping, key=sortBy):
        ...     print('{0}:'.format(classDocumenter.referentPackagesystemPath))
        ...     for attributeDocumenter in mapping[classDocumenter][:10]:
        ...         print('- {0}'.format(attributeDocumenter.referentPackagesystemPath))
        ...
        music21.base.Music21Object:
        - music21.base.Music21Object.activeSite
        - music21.base.Music21Object.offset
        - music21.base.Music21Object.offsetFloat
        - music21.base.Music21Object.offsetRational
        - music21.base.Music21Object.priority
        - music21.base.Music21Object.quarterLength
        - music21.base.Music21Object.quarterLengthFloat
        music21.stream.Stream:
        - music21.stream.Stream.atSoundingPitch
        - music21.stream.Stream.duration
        - music21.stream.Stream.elements
        - music21.stream.Stream.finalBarline
        - music21.stream.Stream.metadata
        - music21.stream.Stream.seconds

        '''
        return self._inheritedReadwritePropertiesMapping

    @property
    def methods(self):
        '''
        The method documenters for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Stream
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for method in documenter.methods[:10]:
        ...     method
        ...
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.activateVariants>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.addGroupForElements>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.allPlayingWhileSounding>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.analyze>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.append>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.asTimespans>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.attachIntervalsBetweenStreams>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.attachMelodicIntervals>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.attributeCount>
        <music21.documentation.library.documenters.MethodDocumenter: music21.stream.Stream.augmentOrDiminish>

        '''
        return self._methods

    @property
    def readonlyProperties(self):
        '''
        The read-only property documenters for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Stream
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for attr in documenter.readonlyProperties:
        ...     attr
        ...
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.beat>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.beatDuration>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.beatStr>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.beatStrength>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.flat>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.highestOffset>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.highestTime>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.isGapless>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.lowestOffset>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.notes>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.notesAndRests>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.offsetMap>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.pitches>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.secondsMap>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.semiFlat>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.sorted>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.spannerBundle>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.spanners>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.variants>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.voices>

        '''
        return self._readonlyProperties

    @property
    def readwriteProperties(self):
        '''
        The read/write property documenters for a documented class:

        >>> from music21 import documentation, stream
        >>> klass = stream.Stream
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for prop in documenter.readwriteProperties:
        ...     prop
        ...
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.atSoundingPitch>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.duration>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.elements>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.finalBarline>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.metadata>
        <music21.documentation.library.documenters.AttributeDocumenter: music21.stream.Stream.seconds>

        '''
        return self._readwriteProperties

    @property
    def referentPackagesystemPath(self):
        path = '.'.join((
            self.referent.__module__,
            self.referent.__name__,
            ))
        return path.replace('.__init__', '')

    @property
    def rstAutodocDirectiveFormat(self):
        result = []
        referentPackagesystemPath = self.referentPackagesystemPath.replace(
            '.__init__', '')
        result.append('.. autoclass:: {0}'.format(
            referentPackagesystemPath,
            ))
        result.append('')
        return result

    @property
    def rstBasesFormat(self):
        '''
        The ReST format for the bases from which the documented class
        inherits:

        >>> from music21 import documentation
        >>> klass = documentation.ClassDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstBasesFormat:
        ...     line
        ...
        '.. rubric:: :class:`~music21.documentation.library.documenters.ClassDocumenter` bases'
        ''
        '- :class:`~music21.documentation.library.documenters.ObjectDocumenter`'
        '- :class:`~music21.documentation.library.documenters.Documenter`'
        ''

        '''
        result = []
        if self.baseClasses:
            banner = '{0} bases'.format(self.rstCrossReferenceString)
            result.extend(self.makeRubric(banner))
            #result.extend(self.makeHeading(banner, 3))
            for class_documenter in self.baseClassDocumenters:
                result.append('- {0}'.format(
                    class_documenter.rstCrossReferenceString))
            result.append('')
        return result

    @property
    def rstDocAttrFormat(self):
        result = []
        if self.docAttr:
            for attrName, attrDescription in sorted(self.docAttr.items()):
                path = '{0}.{1}'.format(
                    self.referentPackagesystemPath.split('.')[-1],
                    attrName,
                    )
                directive = '.. attribute:: {0}'.format(path)
                result.extend((directive, ''))
                for line in attrDescription.split('\n'):
                    result.append('\t{0}'.format(line.strip()))
                result.append('')
        result.extend(self.rstInheritedDocAttrFormat)
        if result:
            banner = '{0} instance variables'.format(
                self.rstCrossReferenceString)
            result = self.makeRubric(banner) + result
            #result = self.makeHeading(banner, 3) + result
        return result

    @property
    def rstInheritedDocAttrFormat(self):
        result = []
        for baseDocumenter in self.baseClassDocumenters:
            if baseDocumenter in self.inheritedDocAttrMapping:
                attrNames = self.inheritedDocAttrMapping[baseDocumenter].keys()
                if not attrNames:
                    continue
                banner = 'Instance variables inherited from {0}:'.format(
                    baseDocumenter.rstCrossReferenceString)
                result.extend((banner, ''))
                result.append('.. hlist::')
                result.append('   :columns: 3')
                result.append('')
                formatString = '   - :attr:`~{0}.{1}`'
                for attrName in attrNames:
                    result.append(formatString.format(
                        baseDocumenter.referentPackagesystemPath,
                        attrName,
                        ))
                result.append('')
        return result

    @property
    def rstInheritedMethodsFormat(self):
        r'''
        The ReST format for inherited methods:

        >>> from music21 import documentation
        >>> klass = documentation.MethodDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstInheritedMethodsFormat:
        ...     line
        ...
        'Methods inherited from :class:`~music21.documentation.library.documenters.MemberDocumenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :meth:`~music21.documentation.library.documenters.MemberDocumenter.run`'
        ''
        'Methods inherited from :class:`~music21.documentation.library.documenters.Documenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :meth:`~music21.documentation.library.documenters.Documenter.makeHeading`'
        '   - :meth:`~music21.documentation.library.documenters.Documenter.makeRubric`'
        ''

        '''
        mapping = self.inheritedMethodsMapping
        banner = 'Methods inherited from {0}:'
        return self._formatInheritedMembersMapping(mapping, banner)


    @property
    def rstInheritedReadonlyPropertiesFormat(self):
        r'''
        The ReST format for inherited methods:

        >>> from music21 import documentation
        >>> klass = documentation.MethodDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstInheritedReadonlyPropertiesFormat:
        ...     line
        ...
        'Read-only properties inherited from :class:`~music21.documentation.library.documenters.MemberDocumenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :attr:`~music21.documentation.library.documenters.MemberDocumenter.definingClass`'
        '   - :attr:`~music21.documentation.library.documenters.MemberDocumenter.memberName`'
        '   - :attr:`~music21.documentation.library.documenters.MemberDocumenter.referentPackagesystemPath`'
        ''
        'Read-only properties inherited from :class:`~music21.documentation.library.documenters.ObjectDocumenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :attr:`~music21.documentation.library.documenters.ObjectDocumenter.referent`'
        '   - :attr:`~music21.documentation.library.documenters.ObjectDocumenter.rstCrossReferenceString`'
        ''
        'Read-only properties inherited from :class:`~music21.documentation.library.documenters.Documenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :attr:`~music21.documentation.library.documenters.Documenter.rstEditingWarningFormat`'
        ''

        '''
        mapping = self.inheritedReadonlyPropertiesMapping
        banner = 'Read-only properties inherited from {0}:'
        return self._formatInheritedMembersMapping(mapping, banner)

    @property
    def rstInheritedReadwritePropertiesFormat(self):
        '''
        The ReST format for inherited methods:

        >>> from music21 import documentation
        >>> klass = documentation.MethodDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstInheritedReadwritePropertiesFormat:
        ...     line
        ...

        '''
        mapping = self.inheritedReadwritePropertiesMapping
        banner = 'Read/write properties inherited from {0}:'
        return self._formatInheritedMembersMapping(mapping, banner)

    @property
    def rstMethodsFormat(self):
        r'''
        The ReST format for the documented class's methods:

        >>> from music21 import documentation
        >>> klass = documentation.ClassDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstMethodsFormat:
        ...     line
        ...
        '.. rubric:: :class:`~music21.documentation.library.documenters.ClassDocumenter` methods'
        ''
        '.. automethod:: music21.documentation.library.documenters.ClassDocumenter.fromIdentityMap'
        ''
        '.. automethod:: music21.documentation.library.documenters.ClassDocumenter.run'
        ''
        'Methods inherited from :class:`~music21.documentation.library.documenters.Documenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :meth:`~music21.documentation.library.documenters.Documenter.makeHeading`'
        '   - :meth:`~music21.documentation.library.documenters.Documenter.makeRubric`'
        ''

        '''
        result = []
        if self.methods:
            for documenter in self.methods:
                result.extend(documenter.run())
            if result[-1] != '':
                result.append('')
        result.extend(self.rstInheritedMethodsFormat)
        if result:
            banner = '{0} methods'.format(self.rstCrossReferenceString)
            #result = self.makeHeading(banner, 3) + result
            result = self.makeRubric(banner) + result
        return result

    @property
    def rstReadonlyPropertiesFormat(self):
        r'''
        The ReST format for the documented class's read-only properties:

        >>> from music21 import documentation
        >>> klass = documentation.ClassDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstReadonlyPropertiesFormat:
        ...     line
        ...
        '.. rubric:: :class:`~music21.documentation.library.documenters.ClassDocumenter` read-only properties'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.baseClassDocumenters'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.baseClasses'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.docAttr'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.docOrder'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.inheritedDocAttrMapping'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.inheritedMethodsMapping'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.inheritedReadonlyPropertiesMapping'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.inheritedReadwritePropertiesMapping'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.methods'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.readonlyProperties'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.readwriteProperties'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.referentPackagesystemPath'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstAutodocDirectiveFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstBasesFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstDocAttrFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstInheritedDocAttrFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstInheritedMethodsFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstInheritedReadonlyPropertiesFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstInheritedReadwritePropertiesFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstMethodsFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstReadonlyPropertiesFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.rstReadwritePropertiesFormat'
        ''
        '.. autoattribute:: music21.documentation.library.documenters.ClassDocumenter.sphinxCrossReferenceRole'
        ''
        'Read-only properties inherited from :class:`~music21.documentation.library.documenters.ObjectDocumenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :attr:`~music21.documentation.library.documenters.ObjectDocumenter.referent`'
        '   - :attr:`~music21.documentation.library.documenters.ObjectDocumenter.rstCrossReferenceString`'
        ''
        'Read-only properties inherited from :class:`~music21.documentation.library.documenters.Documenter`:'
        ''
        '.. hlist::'
        '   :columns: 3'
        ''
        '   - :attr:`~music21.documentation.library.documenters.Documenter.rstEditingWarningFormat`'
        ''

        '''
        result = []
        if self.readonlyProperties:
            for documenter in self.readonlyProperties:
                result.extend(documenter.run())
            if result[-1] != '':
                result.append('')
        result.extend(self.rstInheritedReadonlyPropertiesFormat)
        if result:
            banner = '{0} read-only properties'.format(
                self.rstCrossReferenceString)
            result = self.makeRubric(banner) + result
        return result

    @property
    def rstReadwritePropertiesFormat(self):
        '''
        The ReST format for the documented class's read-only properties:

        >>> from music21 import documentation
        >>> klass = documentation.ClassDocumenter
        >>> documenter = documentation.ClassDocumenter(klass)
        >>> for line in documenter.rstReadwritePropertiesFormat:
        ...     line
        ...

        '''
        result = []
        if self.readwriteProperties:
            for documenter in self.readwriteProperties:
                result.extend(documenter.run())
            if result[-1] != '':
                result.append('')
        result.extend(self.rstInheritedReadwritePropertiesFormat)
        if result:
            banner = '{0} read/write properties'.format(
                self.rstCrossReferenceString)
            result = self.makeRubric(banner) + result
        return result

    @property
    def sphinxCrossReferenceRole(self):
        return 'class'


class ModuleDocumenter(ObjectDocumenter):
    '''
    A documenter for one module:

    >>> from music21 import documentation, serial
    >>> documenter = documentation.ModuleDocumenter(serial)
    >>> documenter
    <music21.documentation.library.documenters.ModuleDocumenter: music21.serial>

    >>> for reference, referent in sorted(list(
    ...     documenter.namesMapping.items())):
    ...     print("%s %s" % (reference, referent))
    ...
    ContiguousSegmentOfNotes <music21.documentation.library.documenters.ClassDocumenter: music21.serial.ContiguousSegmentOfNotes>
    HistoricalTwelveToneRow <music21.documentation.library.documenters.ClassDocumenter: music21.serial.HistoricalTwelveToneRow>
    ToneRow <music21.documentation.library.documenters.ClassDocumenter: music21.serial.ToneRow>
    TwelveToneMatrix <music21.documentation.library.documenters.ClassDocumenter: music21.serial.TwelveToneMatrix>
    TwelveToneRow <music21.documentation.library.documenters.ClassDocumenter: music21.serial.TwelveToneRow>
    findMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findMultisets>
    findSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findSegments>
    findTransformedSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findTransformedSegments>
    findTransposedAndInvertedMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findTransposedAndInvertedMultisets>
    findTransposedMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findTransposedMultisets>
    findTransposedSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.findTransposedSegments>
    getContiguousSegmentsOfLength <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.getContiguousSegmentsOfLength>
    getHistoricalRowByName <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.getHistoricalRowByName>
    labelMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelMultisets>
    labelSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelSegments>
    labelTransformedSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelTransformedSegments>
    labelTransposedAndInvertedMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelTransposedAndInvertedMultisets>
    labelTransposedMultisets <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelTransposedMultisets>
    labelTransposedSegments <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.labelTransposedSegments>
    pcToToneRow <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.pcToToneRow>
    rowToMatrix <music21.documentation.library.documenters.FunctionDocumenter: music21.serial.rowToMatrix>

    >>> documenter.rstCrossReferenceString
    ':mod:`~music21.serial`'

    >>> for line in documenter.rstAutodocDirectiveFormat:
    ...     line
    ...
    '.. automodule:: music21.serial'
    ''

    Call the documenter to generate the ReStructuredText format:

    >>> restructuredText = documenter.run()

    '''

    ### CLASS VARIABLES ###

    _ignored_classes = frozenset((
        BaseException,
        unittest.TestCase,
        ))

    ### INITIALIZER ###

    def __init__(self, referent):
        assert isinstance(referent, types.ModuleType)
        ObjectDocumenter.__init__(self, referent)
        namesMapping = self._examineModule()
        self._namesMapping = namesMapping
        self._memberOrder = tuple(
            self.referent.__dict__.get('_DOC_ORDER') or ())

    ### SPECIAL METHODS ###

    def run(self):
        result = []
        result.extend(self.rstPageReferenceFormat)
        referentPackagesystemPath = self.referentPackagesystemPath.replace(
            '.__init__', '')
        result.extend(self.makeHeading(referentPackagesystemPath, 1))
        result.extend(self.rstEditingWarningFormat)
        result.extend(self.rstAutodocDirectiveFormat)
        if self.functionDocumenters:
            result.extend(self.makeHeading('Functions', 2))
            for functionDocumenter in self.functionDocumenters:
                result.extend(functionDocumenter.run())
        for classDocumenter in self.classDocumenters:
            result.extend(classDocumenter.run())
        return result

    def __repr__(self):
        return '<{0}: {1}>'.format(
            self._packagesystemPath,
            self.referentPackagesystemPath,
            )

    ### PRIVATE METHODS ###

    def _examineModule(self):
        namesMapping = {}
        for name in dir(self.referent):
            if name.startswith('_'):
                continue
            named = getattr(self.referent, name)
            if isinstance(named, six.class_types):
                if set(inspect.getmro(named)).intersection(
                    self._ignored_classes):
                    continue
                if named.__module__ != self.referent.__name__:
                    continue
                namesMapping[name] = ClassDocumenter(named)
            elif isinstance(named, types.FunctionType) \
                and not named.__name__ == '<lambda>':
                if named.__module__ != self.referent.__name__:
                    continue
                namesMapping[name] = FunctionDocumenter(named)
        return namesMapping

    ### PUBLIC PROPERTIES ###

    @property
    def classDocumenters(self):
        '''
        Return a list of class documenters for classes housed in the
        module documenter's module object, taking into account any ordering
        via the `_DOC_ORDER` module-level variable:

        >>> from music21 import documentation, serial
        >>> module = serial
        >>> documenter = documentation.ModuleDocumenter(module)
        >>> for classDocumenter in documenter.classDocumenters:
        ...     print(classDocumenter.referentPackagesystemPath)
        ...
        music21.serial.ContiguousSegmentOfNotes
        music21.serial.HistoricalTwelveToneRow
        music21.serial.ToneRow
        music21.serial.TwelveToneMatrix
        music21.serial.TwelveToneRow

        '''
        result = []
        classDocumenters = {}
        for documenter in self.namesMapping.values():
            if isinstance(documenter, ClassDocumenter):
                classDocumenters[documenter.referent] = documenter
        for referent in self.memberOrder:
            if referent in classDocumenters:
                result.append(classDocumenters[referent])
                del(classDocumenters[referent])
        for documenter in sorted(classDocumenters.values(),
            key=lambda x: x.referentPackagesystemPath):
            result.append(documenter)
        return result

    @property
    def functionDocumenters(self):
        '''
        Return a list of class documenters for classes housed in the
        module documenter's module object, taking into account any ordering
        via the `_DOC_ORDER` module-level variable:

        >>> from music21 import documentation, serial
        >>> module = serial
        >>> documenter = documentation.ModuleDocumenter(module)
        >>> for functionDocumenter in documenter.functionDocumenters:
        ...     print(functionDocumenter.referentPackagesystemPath)
        ...
        music21.serial.findMultisets
        music21.serial.findSegments
        music21.serial.findTransformedSegments
        music21.serial.findTransposedAndInvertedMultisets
        music21.serial.findTransposedMultisets
        music21.serial.findTransposedSegments
        music21.serial.getContiguousSegmentsOfLength
        music21.serial.getHistoricalRowByName
        music21.serial.labelMultisets
        music21.serial.labelSegments
        music21.serial.labelTransformedSegments
        music21.serial.labelTransposedAndInvertedMultisets
        music21.serial.labelTransposedMultisets
        music21.serial.labelTransposedSegments
        music21.serial.pcToToneRow
        music21.serial.rowToMatrix

        '''
        result = []
        functionDocumenters = {}
        for documenter in self.namesMapping.values():
            if isinstance(documenter, FunctionDocumenter):
                functionDocumenters[documenter.referent] = documenter
        for referent in self.memberOrder:
            if referent in functionDocumenters:
                result.append(functionDocumenters[referent])
                del(functionDocumenters[referent])
        for documenter in sorted(functionDocumenters.values(),
            key=lambda x: x.referentPackagesystemPath):
            result.append(documenter)
        return result

    @property
    def namesMapping(self):
        return self._namesMapping

    @property
    def memberOrder(self):
        return self._memberOrder

    @property
    def referentPackagesystemPath(self):
        if isinstance(self.referent.__name__, tuple):
            path = self.referent.__name__[0],
        else:
            path = self.referent.__name__
        return path.replace('.__init__', '')

    @property
    def rstAutodocDirectiveFormat(self):
        result = []
        result.append('.. automodule:: {0}'.format(
            self.referentPackagesystemPath,
            ))
        result.append('')
        return result

    @property
    def rstPageReferenceFormat(self):
        result = []
        result.append('.. _{0}:'.format(self.referenceName))
        result.append('')
        return result

    @property
    def referenceName(self):
        '''The short name of the module:

        >>> from music21 import documentation, serial
        >>> module = serial
        >>> documenter = documentation.ModuleDocumenter(module)
        >>> documenter.referenceName
        'moduleSerial'

        >>> from music21.stream import makeNotation
        >>> module = makeNotation
        >>> documenter = documentation.ModuleDocumenter(module)
        >>> documenter.referenceName
        'moduleStreamMakeNotation'

        '''
        referentPackagesystemPath = self.referentPackagesystemPath.replace(
            '.__init__', '')
        parts = referentPackagesystemPath.split('.')[1:]
        for i, part in enumerate(parts):
            if not part[0].isupper():
                parts[i] = part[0].upper() + part[1:]
        parts = ['module'] + parts
        return ''.join(parts)

    @property
    def sphinxCrossReferenceRole(self):
        return 'mod'


class CorpusDocumenter(Documenter):
    '''A documenter for music21's corpus:

    >>> from music21 import documentation
    >>> documenter = documentation.CorpusDocumenter()
    >>> restructuredText = documenter.run()

    '''

    ### SPECIAL METHODS ###

    def run(self):
        from music21 import corpus
        result = []
        result.extend(self.rstPageReferenceFormat)
        result.extend(self.makeHeading(self.headingText, 1))
        result.extend(self.rstEditingWarningFormat)
        result.extend(self.rstCorpusIntroductionFormat)
        for composerDict in corpus.getWorkReferences(sort=True):
            result.extend(self.getRstComposerDictFormat(composerDict))
        return result

    def __repr__(self):
        return '<{0}>'.format(self._packagesystemPath)

    ### PUBLIC PROPERTIES ###

    @property
    def headingText(self):
        return 'List of Works Found in the music21 Corpus'

    @property
    def rstCorpusIntroductionFormat(self):
        result = []
        result.append('The following list shows all files available in the ')
        result.append('music21 corpus and available through the virtual corpus.')
        result.append('To load a work from the corpus, provide the file path ')
        result.append('stub provided.')
        result.append('')
        result.append('For example:')
        result.append('')
        result.append('::')
        result.append('')
        result.append('   >>> from music21 import corpus')
        result.append("   >>> s = corpus.parse('bach/bwv108.6.xml')")
        result.append('')
        return result

    @property
    def rstPageReferenceFormat(self):
        result = []
        result.append('.. _referenceCorpus:')
        result.append('')
        return result

    ### PUBLIC METHODS ###

    def getRstComposerDictFormat(self, composerDict):
        result = []
        composerName = composerDict['composer']
        composerDirectory = composerDict['composerDir']
        result.extend(self.makeHeading(composerName, 2))
        result.extend(self.getRstComposerIntroductionFormat(
            composerName,
            composerDirectory,
            ))
        for workKey in composerDict['sortedWorkKeys']:
            workDict = composerDict['works'][workKey]
            result.extend(self.getRstComposerWorksFormat(workDict))
        return result

    def getRstComposerIntroductionFormat(
        self, composerName, composerDirectory):
        result = []
        result.append('To get all works by {0}, the'.format(composerName))
        result.append(':meth:`~music21.corpus.getComposer` function can')
        result.append('be used to get all file paths.')
        result.append('')
        result.append('For example:')
        result.append('')
        result.append('::')
        result.append('')
        result.append('    >>> from music21 import corpus')
        result.append('    >>> paths = corpus.getComposer({!r})'.format(
            composerDirectory))
        result.append('')
        return result

    def getRstComposerWorksFormat(self, workDict):
        result = []
        #workTitle = common.toUnicode(workDict['title'])
        workTitle = unicode(workDict['title'])
        worksAreVirtual = workDict['virtual']
        if worksAreVirtual:
            workTitle += ' (*virtual*)'
        result.append(workTitle)
        result.append('')
        procedure = self.getRstWorkFileDictFormat
        if worksAreVirtual:
            procedure = self.getRstVirtualWorkFileDictFormat
        for fileDict in workDict['files']:
            result.extend(procedure(fileDict))
        return result

    def getRstVirtualWorkFileDictFormat(self, fileDict):
        result = []
        result.append('- {0} *({1})*: `{2}`'.format(
            unicode(fileDict['title']),
            unicode(fileDict['format']),
            unicode(fileDict['corpusPath']),
            ))
        result.append('')
        result.append('  Source: {0}'.format(
            unicode(fileDict['url'])))
        result.append('')
        return result

    def getRstWorkFileDictFormat(self, fileDict):
        result = []
        corpusPathWithoutSlashes = re.sub(
            '\\\\',
            '/',
            fileDict['corpusPath'],
            )
        result.append('- {0} *({1})*: `{2}`'.format(
            fileDict['title'],
            fileDict['format'],
            corpusPathWithoutSlashes,
            ))
        result.append('')
        return result


if __name__ == '__main__':
    import music21
    music21.mainTest()
